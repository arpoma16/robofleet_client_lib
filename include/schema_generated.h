// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMAMAIN_H_
#define FLATBUFFERS_GENERATED_SCHEMAMAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct MsgMetadata;
struct MsgMetadataBuilder;

struct MsgWithMetadata;
struct MsgWithMetadataBuilder;

struct RosTime;

struct RosDuration;

namespace std_msgs {

struct Header;
struct HeaderBuilder;

struct String;
struct StringBuilder;

struct Float64;
struct Float64Builder;

struct Float32;
struct Float32Builder;

struct UInt8;
struct UInt8Builder;

}  // namespace std_msgs

namespace geometry_msgs {

struct Point;
struct PointBuilder;

struct Quaternion;
struct QuaternionBuilder;

struct Pose;
struct PoseBuilder;

struct PoseStamped;
struct PoseStampedBuilder;

struct PoseWithCovariance;
struct PoseWithCovarianceBuilder;

struct PoseWithCovarianceStamped;
struct PoseWithCovarianceStampedBuilder;

struct Vector3;
struct Vector3Builder;

struct Vector3Stamped;
struct Vector3StampedBuilder;

struct Twist;
struct TwistBuilder;

struct TwistStamped;
struct TwistStampedBuilder;

struct TwistWithCovariance;
struct TwistWithCovarianceBuilder;

}  // namespace geometry_msgs

namespace sensor_msgs {

struct NavSatStatus;
struct NavSatStatusBuilder;

struct NavSatFix;
struct NavSatFixBuilder;

struct BatteryState;
struct BatteryStateBuilder;

struct Imu;
struct ImuBuilder;

struct LaserScan;
struct LaserScanBuilder;

struct CompressedImage;
struct CompressedImageBuilder;

struct PointField;
struct PointFieldBuilder;

struct PointCloud2;
struct PointCloud2Builder;

}  // namespace sensor_msgs

namespace amrl_msgs {

struct RobofleetStatus;
struct RobofleetStatusBuilder;

struct RobofleetSubscription;
struct RobofleetSubscriptionBuilder;

struct ElevatorStatus;
struct ElevatorStatusBuilder;

struct ElevatorCommand;
struct ElevatorCommandBuilder;

struct ErrorReport;
struct ErrorReportBuilder;

struct Pose2Df;
struct Pose2DfBuilder;

struct Localization2DMsg;
struct Localization2DMsgBuilder;

struct PathVisualization;
struct PathVisualizationBuilder;

struct Point2D;
struct Point2DBuilder;

struct ColoredPoint2D;
struct ColoredPoint2DBuilder;

struct ColoredLine2D;
struct ColoredLine2DBuilder;

struct ColoredArc2D;
struct ColoredArc2DBuilder;

struct VisualizationMsg;
struct VisualizationMsgBuilder;

}  // namespace amrl_msgs

namespace nav_msgs {

struct Odometry;
struct OdometryBuilder;

}  // namespace nav_msgs

namespace std_srvs {

struct Empty;
struct EmptyBuilder;

struct EmptyRequest;
struct EmptyRequestBuilder;

struct EmptyResponse;
struct EmptyResponseBuilder;

struct Trigger;
struct TriggerBuilder;

struct TriggerRequest;
struct TriggerRequestBuilder;

struct TriggerResponse;
struct TriggerResponseBuilder;

struct SetBool;
struct SetBoolBuilder;

struct SetBoolRequest;
struct SetBoolRequestBuilder;

struct SetBoolResponse;
struct SetBoolResponseBuilder;

}  // namespace std_srvs

namespace aerialcore_common {

struct ConfigMission;
struct ConfigMissionBuilder;

struct ConfigMissionRequest;
struct ConfigMissionRequestBuilder;

struct ConfigMissionResponse;
struct ConfigMissionResponseBuilder;

struct eventService;
struct eventServiceBuilder;

struct eventRequest;
struct eventRequestBuilder;

struct eventResponse;
struct eventResponseBuilder;

}  // namespace aerialcore_common

namespace dji_osdk_ros {

struct ObstacleInfo;
struct ObstacleInfoBuilder;

struct WaypointV2MissionStatePush;
struct WaypointV2MissionStatePushBuilder;

}  // namespace dji_osdk_ros

namespace mavros_msgs {

struct Altitude;
struct AltitudeBuilder;

}  // namespace mavros_msgs

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosTime FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t secs_;
  uint32_t nsecs_;

 public:
  RosTime()
      : secs_(0),
        nsecs_(0) {
  }
  RosTime(uint32_t _secs, uint32_t _nsecs)
      : secs_(::flatbuffers::EndianScalar(_secs)),
        nsecs_(::flatbuffers::EndianScalar(_nsecs)) {
  }
  uint32_t secs() const {
    return ::flatbuffers::EndianScalar(secs_);
  }
  uint32_t nsecs() const {
    return ::flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosTime, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosDuration FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t secs_;
  int32_t nsecs_;

 public:
  RosDuration()
      : secs_(0),
        nsecs_(0) {
  }
  RosDuration(int32_t _secs, int32_t _nsecs)
      : secs_(::flatbuffers::EndianScalar(_secs)),
        nsecs_(::flatbuffers::EndianScalar(_nsecs)) {
  }
  int32_t secs() const {
    return ::flatbuffers::EndianScalar(secs_);
  }
  int32_t nsecs() const {
    return ::flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosDuration, 8);

struct MsgMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MsgMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TOPIC = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
};

struct MsgMetadataBuilder {
  typedef MsgMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(MsgMetadata::VT_TYPE, type);
  }
  void add_topic(::flatbuffers::Offset<::flatbuffers::String> topic) {
    fbb_.AddOffset(MsgMetadata::VT_TOPIC, topic);
  }
  explicit MsgMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MsgMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MsgMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> topic = 0) {
  MsgMetadataBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MsgMetadata> CreateMsgMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *topic = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return fb::CreateMsgMetadata(
      _fbb,
      type__,
      topic__);
}

struct MsgWithMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MsgWithMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
};

struct MsgWithMetadataBuilder {
  typedef MsgWithMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MsgWithMetadata::VT___METADATA, __metadata);
  }
  explicit MsgWithMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MsgWithMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MsgWithMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  MsgWithMetadataBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

namespace std_msgs {

struct Header FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SEQ = 6,
    VT_STAMP = 8,
    VT_FRAME_ID = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t seq() const {
    return GetField<uint32_t>(VT_SEQ, 0);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const ::flatbuffers::String *frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_SEQ, 4) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_STAMP, 4) &&
           VerifyOffsetRequired(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  typedef Header Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Header::VT___METADATA, __metadata);
  }
  void add_seq(uint32_t seq) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQ, seq, 0);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(Header::VT_STAMP, stamp);
  }
  void add_frame_id(::flatbuffers::Offset<::flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Header>(end);
    fbb_.Required(o, Header::VT_STAMP);
    fbb_.Required(o, Header::VT_FRAME_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<Header> CreateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_frame_id(frame_id);
  builder_.add_stamp(stamp);
  builder_.add_seq(seq);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Header> CreateHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = nullptr,
    const char *frame_id = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fb::std_msgs::CreateHeader(
      _fbb,
      __metadata,
      seq,
      stamp,
      frame_id__);
}

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(String::VT___METADATA, __metadata);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(String::VT_DATA, data);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    fbb_.Required(o, String::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return fb::std_msgs::CreateString(
      _fbb,
      __metadata,
      data__);
}

struct Float64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double data() const {
    return GetField<double>(VT_DATA, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_DATA, 8) &&
           verifier.EndTable();
  }
};

struct Float64Builder {
  typedef Float64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Float64::VT___METADATA, __metadata);
  }
  void add_data(double data) {
    fbb_.AddElement<double>(Float64::VT_DATA, data, 0.0);
  }
  explicit Float64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Float64> CreateFloat64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double data = 0.0) {
  Float64Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Float32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float data() const {
    return GetField<float>(VT_DATA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
};

struct Float32Builder {
  typedef Float32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Float32::VT___METADATA, __metadata);
  }
  void add_data(float data) {
    fbb_.AddElement<float>(Float32::VT_DATA, data, 0.0f);
  }
  explicit Float32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Float32> CreateFloat32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float data = 0.0f) {
  Float32Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct UInt8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t data() const {
    return GetField<uint8_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
};

struct UInt8Builder {
  typedef UInt8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt8::VT___METADATA, __metadata);
  }
  void add_data(uint8_t data) {
    fbb_.AddElement<uint8_t>(UInt8::VT_DATA, data, 0);
  }
  explicit UInt8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt8> CreateUInt8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t data = 0) {
  UInt8Builder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

}  // namespace std_msgs

namespace geometry_msgs {

struct Point FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           verifier.EndTable();
  }
};

struct PointBuilder {
  typedef Point Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Point::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Point::VT_Z, z, 0.0);
  }
  explicit PointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Point>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Point> CreatePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  PointBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuaternionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_W = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double w() const {
    return GetField<double>(VT_W, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_W, 8) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Quaternion::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Quaternion::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaternion::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaternion::VT_Z, z, 0.0);
  }
  void add_w(double w) {
    fbb_.AddElement<double>(Quaternion::VT_W, w, 0.0);
  }
  explicit QuaternionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Quaternion> CreateQuaternion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double w = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Pose FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  typedef Pose Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose::VT___METADATA, __metadata);
  }
  void add_position(::flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Pose::VT_POSITION, position);
  }
  void add_orientation(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Pose::VT_ORIENTATION, orientation);
  }
  explicit PoseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pose>(end);
    fbb_.Required(o, Pose::VT_POSITION);
    fbb_.Required(o, Pose::VT_ORIENTATION);
    return o;
  }
};

inline ::flatbuffers::Offset<Pose> CreatePose(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct PoseStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
};

struct PoseStampedBuilder {
  typedef PoseStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseStamped::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseStamped::VT_POSE, pose);
  }
  explicit PoseStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseStamped>(end);
    fbb_.Required(o, PoseStamped::VT_HEADER);
    fbb_.Required(o, PoseStamped::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseStamped> CreatePoseStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0) {
  PoseStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct PoseWithCovariance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const ::flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
};

struct PoseWithCovarianceBuilder {
  typedef PoseWithCovariance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(PoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit PoseWithCovarianceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseWithCovariance>(end);
    fbb_.Required(o, PoseWithCovariance::VT_POSE);
    fbb_.Required(o, PoseWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance = 0) {
  PoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovarianceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

struct PoseWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
};

struct PoseWithCovarianceStampedBuilder {
  typedef PoseWithCovarianceStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT_POSE, pose);
  }
  explicit PoseWithCovarianceStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseWithCovarianceStamped>(end);
    fbb_.Required(o, PoseWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, PoseWithCovarianceStamped::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0) {
  PoseWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Vector3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vector3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           verifier.EndTable();
  }
};

struct Vector3Builder {
  typedef Vector3 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3::VT_Z, z, 0.0);
  }
  explicit Vector3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector3> CreateVector3(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Vector3Stamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vector3StampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_VECTOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Vector3 *vector() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_VECTOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_VECTOR) &&
           verifier.VerifyTable(vector()) &&
           verifier.EndTable();
  }
};

struct Vector3StampedBuilder {
  typedef Vector3Stamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3Stamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Vector3Stamped::VT_HEADER, header);
  }
  void add_vector(::flatbuffers::Offset<fb::geometry_msgs::Vector3> vector) {
    fbb_.AddOffset(Vector3Stamped::VT_VECTOR, vector);
  }
  explicit Vector3StampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector3Stamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector3Stamped>(end);
    fbb_.Required(o, Vector3Stamped::VT_HEADER);
    fbb_.Required(o, Vector3Stamped::VT_VECTOR);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector3Stamped> CreateVector3Stamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> vector = 0) {
  Vector3StampedBuilder builder_(_fbb);
  builder_.add_vector(vector);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Twist FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LINEAR = 6,
    VT_ANGULAR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *linear() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR);
  }
  const fb::geometry_msgs::Vector3 *angular() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           verifier.EndTable();
  }
};

struct TwistBuilder {
  typedef Twist Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Twist::VT___METADATA, __metadata);
  }
  void add_linear(::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear) {
    fbb_.AddOffset(Twist::VT_LINEAR, linear);
  }
  void add_angular(::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular) {
    fbb_.AddOffset(Twist::VT_ANGULAR, angular);
  }
  explicit TwistBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Twist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Twist>(end);
    fbb_.Required(o, Twist::VT_LINEAR);
    fbb_.Required(o, Twist::VT_ANGULAR);
    return o;
  }
};

inline ::flatbuffers::Offset<Twist> CreateTwist(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular = 0) {
  TwistBuilder builder_(_fbb);
  builder_.add_angular(angular);
  builder_.add_linear(linear);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct TwistStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_TWIST = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
};

struct TwistStampedBuilder {
  typedef TwistStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TwistStamped::VT_HEADER, header);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistStamped::VT_TWIST, twist);
  }
  explicit TwistStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TwistStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TwistStamped>(end);
    fbb_.Required(o, TwistStamped::VT_HEADER);
    fbb_.Required(o, TwistStamped::VT_TWIST);
    return o;
  }
};

inline ::flatbuffers::Offset<TwistStamped> CreateTwistStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0) {
  TwistStampedBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct TwistWithCovariance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TWIST = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  const ::flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
};

struct TwistWithCovarianceBuilder {
  typedef TwistWithCovariance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistWithCovariance::VT___METADATA, __metadata);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistWithCovariance::VT_TWIST, twist);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(TwistWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit TwistWithCovarianceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TwistWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TwistWithCovariance>(end);
    fbb_.Required(o, TwistWithCovariance::VT_TWIST);
    fbb_.Required(o, TwistWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance = 0) {
  TwistWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_twist(twist);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovarianceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      __metadata,
      twist,
      covariance__);
}

}  // namespace geometry_msgs

namespace sensor_msgs {

struct NavSatStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NavSatStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_SERVICE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t status() const {
    return GetField<int8_t>(VT_STATUS, 0);
  }
  uint16_t service() const {
    return GetField<uint16_t>(VT_SERVICE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE, 2) &&
           verifier.EndTable();
  }
};

struct NavSatStatusBuilder {
  typedef NavSatStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatStatus::VT___METADATA, __metadata);
  }
  void add_status(int8_t status) {
    fbb_.AddElement<int8_t>(NavSatStatus::VT_STATUS, status, 0);
  }
  void add_service(uint16_t service) {
    fbb_.AddElement<uint16_t>(NavSatStatus::VT_SERVICE, service, 0);
  }
  explicit NavSatStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NavSatStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NavSatStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t status = 0,
    uint16_t service = 0) {
  NavSatStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_service(service);
  builder_.add_status(status);
  return builder_.Finish();
}

struct NavSatFix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NavSatFixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_ALTITUDE = 14,
    VT_POSITION_COVARIANCE = 16,
    VT_POSITION_COVARIANCE_TYPE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::sensor_msgs::NavSatStatus *status() const {
    return GetPointer<const fb::sensor_msgs::NavSatStatus *>(VT_STATUS);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  const ::flatbuffers::Vector<double> *position_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITION_COVARIANCE);
  }
  uint8_t position_covariance_type() const {
    return GetField<uint8_t>(VT_POSITION_COVARIANCE_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           VerifyOffsetRequired(verifier, VT_POSITION_COVARIANCE) &&
           verifier.VerifyVector(position_covariance()) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_COVARIANCE_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct NavSatFixBuilder {
  typedef NavSatFix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatFix::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NavSatFix::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status) {
    fbb_.AddOffset(NavSatFix::VT_STATUS, status);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(NavSatFix::VT_ALTITUDE, altitude, 0.0);
  }
  void add_position_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> position_covariance) {
    fbb_.AddOffset(NavSatFix::VT_POSITION_COVARIANCE, position_covariance);
  }
  void add_position_covariance_type(uint8_t position_covariance_type) {
    fbb_.AddElement<uint8_t>(NavSatFix::VT_POSITION_COVARIANCE_TYPE, position_covariance_type, 0);
  }
  explicit NavSatFixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NavSatFix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NavSatFix>(end);
    fbb_.Required(o, NavSatFix::VT_HEADER);
    fbb_.Required(o, NavSatFix::VT_STATUS);
    fbb_.Required(o, NavSatFix::VT_POSITION_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<NavSatFix> CreateNavSatFix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> position_covariance = 0,
    uint8_t position_covariance_type = 0) {
  NavSatFixBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_position_covariance(position_covariance);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_position_covariance_type(position_covariance_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NavSatFix> CreateNavSatFixDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    const std::vector<double> *position_covariance = nullptr,
    uint8_t position_covariance_type = 0) {
  auto position_covariance__ = position_covariance ? _fbb.CreateVector<double>(*position_covariance) : 0;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      __metadata,
      header,
      status,
      latitude,
      longitude,
      altitude,
      position_covariance__,
      position_covariance_type);
}

struct BatteryState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatteryStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_VOLTAGE = 8,
    VT_CURRENT = 10,
    VT_CHARGE = 12,
    VT_CAPACITY = 14,
    VT_DESIGN_CAPACITY = 16,
    VT_PERCENTAGE = 18,
    VT_POWER_SUPPLY_STATUS = 20,
    VT_POWER_SUPPLY_HEALTH = 22,
    VT_POWER_SUPPLY_TECHNOLOGY = 24,
    VT_PRESENT = 26,
    VT_CELL_VOLTAGE = 28,
    VT_CELL_TEMPERATURE = 30
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float voltage() const {
    return GetField<float>(VT_VOLTAGE, 0.0f);
  }
  float current() const {
    return GetField<float>(VT_CURRENT, 0.0f);
  }
  float charge() const {
    return GetField<float>(VT_CHARGE, 0.0f);
  }
  float capacity() const {
    return GetField<float>(VT_CAPACITY, 0.0f);
  }
  float design_capacity() const {
    return GetField<float>(VT_DESIGN_CAPACITY, 0.0f);
  }
  float percentage() const {
    return GetField<float>(VT_PERCENTAGE, 0.0f);
  }
  int8_t power_supply_status() const {
    return GetField<int8_t>(VT_POWER_SUPPLY_STATUS, 0);
  }
  int8_t power_supply_health() const {
    return GetField<int8_t>(VT_POWER_SUPPLY_HEALTH, 0);
  }
  int8_t power_supply_technology() const {
    return GetField<int8_t>(VT_POWER_SUPPLY_TECHNOLOGY, 0);
  }
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  const ::flatbuffers::Vector<float> *cell_voltage() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CELL_VOLTAGE);
  }
  const ::flatbuffers::Vector<float> *cell_temperature() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CELL_TEMPERATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_CURRENT, 4) &&
           VerifyField<float>(verifier, VT_CHARGE, 4) &&
           VerifyField<float>(verifier, VT_CAPACITY, 4) &&
           VerifyField<float>(verifier, VT_DESIGN_CAPACITY, 4) &&
           VerifyField<float>(verifier, VT_PERCENTAGE, 4) &&
           VerifyField<int8_t>(verifier, VT_POWER_SUPPLY_STATUS, 1) &&
           VerifyField<int8_t>(verifier, VT_POWER_SUPPLY_HEALTH, 1) &&
           VerifyField<int8_t>(verifier, VT_POWER_SUPPLY_TECHNOLOGY, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT, 1) &&
           VerifyOffsetRequired(verifier, VT_CELL_VOLTAGE) &&
           verifier.VerifyVector(cell_voltage()) &&
           VerifyOffsetRequired(verifier, VT_CELL_TEMPERATURE) &&
           verifier.VerifyVector(cell_temperature()) &&
           verifier.EndTable();
  }
};

struct BatteryStateBuilder {
  typedef BatteryState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BatteryState::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(BatteryState::VT_HEADER, header);
  }
  void add_voltage(float voltage) {
    fbb_.AddElement<float>(BatteryState::VT_VOLTAGE, voltage, 0.0f);
  }
  void add_current(float current) {
    fbb_.AddElement<float>(BatteryState::VT_CURRENT, current, 0.0f);
  }
  void add_charge(float charge) {
    fbb_.AddElement<float>(BatteryState::VT_CHARGE, charge, 0.0f);
  }
  void add_capacity(float capacity) {
    fbb_.AddElement<float>(BatteryState::VT_CAPACITY, capacity, 0.0f);
  }
  void add_design_capacity(float design_capacity) {
    fbb_.AddElement<float>(BatteryState::VT_DESIGN_CAPACITY, design_capacity, 0.0f);
  }
  void add_percentage(float percentage) {
    fbb_.AddElement<float>(BatteryState::VT_PERCENTAGE, percentage, 0.0f);
  }
  void add_power_supply_status(int8_t power_supply_status) {
    fbb_.AddElement<int8_t>(BatteryState::VT_POWER_SUPPLY_STATUS, power_supply_status, 0);
  }
  void add_power_supply_health(int8_t power_supply_health) {
    fbb_.AddElement<int8_t>(BatteryState::VT_POWER_SUPPLY_HEALTH, power_supply_health, 0);
  }
  void add_power_supply_technology(int8_t power_supply_technology) {
    fbb_.AddElement<int8_t>(BatteryState::VT_POWER_SUPPLY_TECHNOLOGY, power_supply_technology, 0);
  }
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(BatteryState::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  void add_cell_voltage(::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_voltage) {
    fbb_.AddOffset(BatteryState::VT_CELL_VOLTAGE, cell_voltage);
  }
  void add_cell_temperature(::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_temperature) {
    fbb_.AddOffset(BatteryState::VT_CELL_TEMPERATURE, cell_temperature);
  }
  explicit BatteryStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatteryState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatteryState>(end);
    fbb_.Required(o, BatteryState::VT_HEADER);
    fbb_.Required(o, BatteryState::VT_CELL_VOLTAGE);
    fbb_.Required(o, BatteryState::VT_CELL_TEMPERATURE);
    return o;
  }
};

inline ::flatbuffers::Offset<BatteryState> CreateBatteryState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float voltage = 0.0f,
    float current = 0.0f,
    float charge = 0.0f,
    float capacity = 0.0f,
    float design_capacity = 0.0f,
    float percentage = 0.0f,
    int8_t power_supply_status = 0,
    int8_t power_supply_health = 0,
    int8_t power_supply_technology = 0,
    bool present = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_voltage = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_temperature = 0) {
  BatteryStateBuilder builder_(_fbb);
  builder_.add_cell_temperature(cell_temperature);
  builder_.add_cell_voltage(cell_voltage);
  builder_.add_percentage(percentage);
  builder_.add_design_capacity(design_capacity);
  builder_.add_capacity(capacity);
  builder_.add_charge(charge);
  builder_.add_current(current);
  builder_.add_voltage(voltage);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_present(present);
  builder_.add_power_supply_technology(power_supply_technology);
  builder_.add_power_supply_health(power_supply_health);
  builder_.add_power_supply_status(power_supply_status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatteryState> CreateBatteryStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float voltage = 0.0f,
    float current = 0.0f,
    float charge = 0.0f,
    float capacity = 0.0f,
    float design_capacity = 0.0f,
    float percentage = 0.0f,
    int8_t power_supply_status = 0,
    int8_t power_supply_health = 0,
    int8_t power_supply_technology = 0,
    bool present = false,
    const std::vector<float> *cell_voltage = nullptr,
    const std::vector<float> *cell_temperature = nullptr) {
  auto cell_voltage__ = cell_voltage ? _fbb.CreateVector<float>(*cell_voltage) : 0;
  auto cell_temperature__ = cell_temperature ? _fbb.CreateVector<float>(*cell_temperature) : 0;
  return fb::sensor_msgs::CreateBatteryState(
      _fbb,
      __metadata,
      header,
      voltage,
      current,
      charge,
      capacity,
      design_capacity,
      percentage,
      power_supply_status,
      power_supply_health,
      power_supply_technology,
      present,
      cell_voltage__,
      cell_temperature__);
}

struct Imu FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImuBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ORIENTATION = 8,
    VT_ORIENTATION_COVARIANCE = 10,
    VT_ANGULAR_VELOCITY = 12,
    VT_ANGULAR_VELOCITY_COVARIANCE = 14,
    VT_LINEAR_ACCELERATION = 16,
    VT_LINEAR_ACCELERATION_COVARIANCE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  const ::flatbuffers::Vector<double> *orientation_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ORIENTATION_COVARIANCE);
  }
  const fb::geometry_msgs::Vector3 *angular_velocity() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR_VELOCITY);
  }
  const ::flatbuffers::Vector<double> *angular_velocity_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ANGULAR_VELOCITY_COVARIANCE);
  }
  const fb::geometry_msgs::Vector3 *linear_acceleration() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR_ACCELERATION);
  }
  const ::flatbuffers::Vector<double> *linear_acceleration_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_LINEAR_ACCELERATION_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION_COVARIANCE) &&
           verifier.VerifyVector(orientation_covariance()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR_VELOCITY) &&
           verifier.VerifyTable(angular_velocity()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR_VELOCITY_COVARIANCE) &&
           verifier.VerifyVector(angular_velocity_covariance()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR_ACCELERATION) &&
           verifier.VerifyTable(linear_acceleration()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR_ACCELERATION_COVARIANCE) &&
           verifier.VerifyVector(linear_acceleration_covariance()) &&
           verifier.EndTable();
  }
};

struct ImuBuilder {
  typedef Imu Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Imu::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Imu::VT_HEADER, header);
  }
  void add_orientation(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Imu::VT_ORIENTATION, orientation);
  }
  void add_orientation_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> orientation_covariance) {
    fbb_.AddOffset(Imu::VT_ORIENTATION_COVARIANCE, orientation_covariance);
  }
  void add_angular_velocity(::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular_velocity) {
    fbb_.AddOffset(Imu::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_angular_velocity_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> angular_velocity_covariance) {
    fbb_.AddOffset(Imu::VT_ANGULAR_VELOCITY_COVARIANCE, angular_velocity_covariance);
  }
  void add_linear_acceleration(::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear_acceleration) {
    fbb_.AddOffset(Imu::VT_LINEAR_ACCELERATION, linear_acceleration);
  }
  void add_linear_acceleration_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> linear_acceleration_covariance) {
    fbb_.AddOffset(Imu::VT_LINEAR_ACCELERATION_COVARIANCE, linear_acceleration_covariance);
  }
  explicit ImuBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Imu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Imu>(end);
    fbb_.Required(o, Imu::VT_HEADER);
    fbb_.Required(o, Imu::VT_ORIENTATION);
    fbb_.Required(o, Imu::VT_ORIENTATION_COVARIANCE);
    fbb_.Required(o, Imu::VT_ANGULAR_VELOCITY);
    fbb_.Required(o, Imu::VT_ANGULAR_VELOCITY_COVARIANCE);
    fbb_.Required(o, Imu::VT_LINEAR_ACCELERATION);
    fbb_.Required(o, Imu::VT_LINEAR_ACCELERATION_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<Imu> CreateImu(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> orientation_covariance = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular_velocity = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> angular_velocity_covariance = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear_acceleration = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> linear_acceleration_covariance = 0) {
  ImuBuilder builder_(_fbb);
  builder_.add_linear_acceleration_covariance(linear_acceleration_covariance);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_angular_velocity_covariance(angular_velocity_covariance);
  builder_.add_angular_velocity(angular_velocity);
  builder_.add_orientation_covariance(orientation_covariance);
  builder_.add_orientation(orientation);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Imu> CreateImuDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0,
    const std::vector<double> *orientation_covariance = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular_velocity = 0,
    const std::vector<double> *angular_velocity_covariance = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear_acceleration = 0,
    const std::vector<double> *linear_acceleration_covariance = nullptr) {
  auto orientation_covariance__ = orientation_covariance ? _fbb.CreateVector<double>(*orientation_covariance) : 0;
  auto angular_velocity_covariance__ = angular_velocity_covariance ? _fbb.CreateVector<double>(*angular_velocity_covariance) : 0;
  auto linear_acceleration_covariance__ = linear_acceleration_covariance ? _fbb.CreateVector<double>(*linear_acceleration_covariance) : 0;
  return fb::sensor_msgs::CreateImu(
      _fbb,
      __metadata,
      header,
      orientation,
      orientation_covariance__,
      angular_velocity,
      angular_velocity_covariance__,
      linear_acceleration,
      linear_acceleration_covariance__);
}

struct LaserScan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LaserScanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ANGLE_MIN = 8,
    VT_ANGLE_MAX = 10,
    VT_ANGLE_INCREMENT = 12,
    VT_TIME_INCREMENT = 14,
    VT_SCAN_TIME = 16,
    VT_RANGE_MIN = 18,
    VT_RANGE_MAX = 20,
    VT_RANGES = 22,
    VT_INTENSITIES = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float angle_min() const {
    return GetField<float>(VT_ANGLE_MIN, 0.0f);
  }
  float angle_max() const {
    return GetField<float>(VT_ANGLE_MAX, 0.0f);
  }
  float angle_increment() const {
    return GetField<float>(VT_ANGLE_INCREMENT, 0.0f);
  }
  float time_increment() const {
    return GetField<float>(VT_TIME_INCREMENT, 0.0f);
  }
  float scan_time() const {
    return GetField<float>(VT_SCAN_TIME, 0.0f);
  }
  float range_min() const {
    return GetField<float>(VT_RANGE_MIN, 0.0f);
  }
  float range_max() const {
    return GetField<float>(VT_RANGE_MAX, 0.0f);
  }
  const ::flatbuffers::Vector<float> *ranges() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_RANGES);
  }
  const ::flatbuffers::Vector<float> *intensities() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_INTENSITIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_ANGLE_MIN, 4) &&
           VerifyField<float>(verifier, VT_ANGLE_MAX, 4) &&
           VerifyField<float>(verifier, VT_ANGLE_INCREMENT, 4) &&
           VerifyField<float>(verifier, VT_TIME_INCREMENT, 4) &&
           VerifyField<float>(verifier, VT_SCAN_TIME, 4) &&
           VerifyField<float>(verifier, VT_RANGE_MIN, 4) &&
           VerifyField<float>(verifier, VT_RANGE_MAX, 4) &&
           VerifyOffsetRequired(verifier, VT_RANGES) &&
           verifier.VerifyVector(ranges()) &&
           VerifyOffsetRequired(verifier, VT_INTENSITIES) &&
           verifier.VerifyVector(intensities()) &&
           verifier.EndTable();
  }
};

struct LaserScanBuilder {
  typedef LaserScan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LaserScan::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LaserScan::VT_HEADER, header);
  }
  void add_angle_min(float angle_min) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MIN, angle_min, 0.0f);
  }
  void add_angle_max(float angle_max) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MAX, angle_max, 0.0f);
  }
  void add_angle_increment(float angle_increment) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_INCREMENT, angle_increment, 0.0f);
  }
  void add_time_increment(float time_increment) {
    fbb_.AddElement<float>(LaserScan::VT_TIME_INCREMENT, time_increment, 0.0f);
  }
  void add_scan_time(float scan_time) {
    fbb_.AddElement<float>(LaserScan::VT_SCAN_TIME, scan_time, 0.0f);
  }
  void add_range_min(float range_min) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MIN, range_min, 0.0f);
  }
  void add_range_max(float range_max) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MAX, range_max, 0.0f);
  }
  void add_ranges(::flatbuffers::Offset<::flatbuffers::Vector<float>> ranges) {
    fbb_.AddOffset(LaserScan::VT_RANGES, ranges);
  }
  void add_intensities(::flatbuffers::Offset<::flatbuffers::Vector<float>> intensities) {
    fbb_.AddOffset(LaserScan::VT_INTENSITIES, intensities);
  }
  explicit LaserScanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LaserScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LaserScan>(end);
    fbb_.Required(o, LaserScan::VT_HEADER);
    fbb_.Required(o, LaserScan::VT_RANGES);
    fbb_.Required(o, LaserScan::VT_INTENSITIES);
    return o;
  }
};

inline ::flatbuffers::Offset<LaserScan> CreateLaserScan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ranges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> intensities = 0) {
  LaserScanBuilder builder_(_fbb);
  builder_.add_intensities(intensities);
  builder_.add_ranges(ranges);
  builder_.add_range_max(range_max);
  builder_.add_range_min(range_min);
  builder_.add_scan_time(scan_time);
  builder_.add_time_increment(time_increment);
  builder_.add_angle_increment(angle_increment);
  builder_.add_angle_max(angle_max);
  builder_.add_angle_min(angle_min);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LaserScan> CreateLaserScanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    const std::vector<float> *ranges = nullptr,
    const std::vector<float> *intensities = nullptr) {
  auto ranges__ = ranges ? _fbb.CreateVector<float>(*ranges) : 0;
  auto intensities__ = intensities ? _fbb.CreateVector<float>(*intensities) : 0;
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      __metadata,
      header,
      angle_min,
      angle_max,
      angle_increment,
      time_increment,
      scan_time,
      range_min,
      range_max,
      ranges__,
      intensities__);
}

struct CompressedImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompressedImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_FORMAT = 8,
    VT_DATA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *format() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMAT);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct CompressedImageBuilder {
  typedef CompressedImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CompressedImage::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(CompressedImage::VT_HEADER, header);
  }
  void add_format(::flatbuffers::Offset<::flatbuffers::String> format) {
    fbb_.AddOffset(CompressedImage::VT_FORMAT, format);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(CompressedImage::VT_DATA, data);
  }
  explicit CompressedImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompressedImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompressedImage>(end);
    fbb_.Required(o, CompressedImage::VT_HEADER);
    fbb_.Required(o, CompressedImage::VT_FORMAT);
    fbb_.Required(o, CompressedImage::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<CompressedImage> CreateCompressedImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> format = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  CompressedImageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_format(format);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompressedImage> CreateCompressedImageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *format = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      __metadata,
      header,
      format__,
      data__);
}

struct PointField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_OFFSET = 8,
    VT_DATATYPE = 10,
    VT_COUNT = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint8_t datatype() const {
    return GetField<uint8_t>(VT_DATATYPE, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATATYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct PointFieldBuilder {
  typedef PointField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointField::VT___METADATA, __metadata);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PointField::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(PointField::VT_OFFSET, offset, 0);
  }
  void add_datatype(uint8_t datatype) {
    fbb_.AddElement<uint8_t>(PointField::VT_DATATYPE, datatype, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(PointField::VT_COUNT, count, 0);
  }
  explicit PointFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointField>(end);
    fbb_.Required(o, PointField::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<PointField> CreatePointField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  PointFieldBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  builder_.add_datatype(datatype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointField> CreatePointFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      __metadata,
      name__,
      offset,
      datatype,
      count);
}

struct PointCloud2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointCloud2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_FIELDS = 12,
    VT_IS_BIGENDIAN = 14,
    VT_POINT_STEP = 16,
    VT_ROW_STEP = 18,
    VT_DATA = 20,
    VT_IS_DENSE = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> *>(VT_FIELDS);
  }
  bool is_bigendian() const {
    return GetField<uint8_t>(VT_IS_BIGENDIAN, 0) != 0;
  }
  uint32_t point_step() const {
    return GetField<uint32_t>(VT_POINT_STEP, 0);
  }
  uint32_t row_step() const {
    return GetField<uint32_t>(VT_ROW_STEP, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool is_dense() const {
    return GetField<uint8_t>(VT_IS_DENSE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyOffsetRequired(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BIGENDIAN, 1) &&
           VerifyField<uint32_t>(verifier, VT_POINT_STEP, 4) &&
           VerifyField<uint32_t>(verifier, VT_ROW_STEP, 4) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_IS_DENSE, 1) &&
           verifier.EndTable();
  }
};

struct PointCloud2Builder {
  typedef PointCloud2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointCloud2::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PointCloud2::VT_HEADER, header);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_WIDTH, width, 0);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields) {
    fbb_.AddOffset(PointCloud2::VT_FIELDS, fields);
  }
  void add_is_bigendian(bool is_bigendian) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_BIGENDIAN, static_cast<uint8_t>(is_bigendian), 0);
  }
  void add_point_step(uint32_t point_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_POINT_STEP, point_step, 0);
  }
  void add_row_step(uint32_t row_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_ROW_STEP, row_step, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(PointCloud2::VT_DATA, data);
  }
  void add_is_dense(bool is_dense) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_DENSE, static_cast<uint8_t>(is_dense), 0);
  }
  explicit PointCloud2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointCloud2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointCloud2>(end);
    fbb_.Required(o, PointCloud2::VT_HEADER);
    fbb_.Required(o, PointCloud2::VT_FIELDS);
    fbb_.Required(o, PointCloud2::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<PointCloud2> CreatePointCloud2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields = 0,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    bool is_dense = false) {
  PointCloud2Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_row_step(row_step);
  builder_.add_point_step(point_step);
  builder_.add_fields(fields);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_is_dense(is_dense);
  builder_.add_is_bigendian(is_bigendian);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointCloud2> CreatePointCloud2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields = nullptr,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    const std::vector<uint8_t> *data = nullptr,
    bool is_dense = false) {
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::PointField>>(*fields) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      __metadata,
      header,
      height,
      width,
      fields__,
      is_bigendian,
      point_step,
      row_step,
      data__,
      is_dense);
}

}  // namespace sensor_msgs

namespace amrl_msgs {

struct RobofleetStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobofleetStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_IS_OK = 8,
    VT_BATTERY_LEVEL = 10,
    VT_LOCATION = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  bool is_ok() const {
    return GetField<uint8_t>(VT_IS_OK, 0) != 0;
  }
  float battery_level() const {
    return GetField<float>(VT_BATTERY_LEVEL, 0.0f);
  }
  const ::flatbuffers::String *location() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint8_t>(verifier, VT_IS_OK, 1) &&
           VerifyField<float>(verifier, VT_BATTERY_LEVEL, 4) &&
           VerifyOffsetRequired(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           verifier.EndTable();
  }
};

struct RobofleetStatusBuilder {
  typedef RobofleetStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetStatus::VT___METADATA, __metadata);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(RobofleetStatus::VT_STATUS, status);
  }
  void add_is_ok(bool is_ok) {
    fbb_.AddElement<uint8_t>(RobofleetStatus::VT_IS_OK, static_cast<uint8_t>(is_ok), 0);
  }
  void add_battery_level(float battery_level) {
    fbb_.AddElement<float>(RobofleetStatus::VT_BATTERY_LEVEL, battery_level, 0.0f);
  }
  void add_location(::flatbuffers::Offset<::flatbuffers::String> location) {
    fbb_.AddOffset(RobofleetStatus::VT_LOCATION, location);
  }
  explicit RobofleetStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RobofleetStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RobofleetStatus>(end);
    fbb_.Required(o, RobofleetStatus::VT_STATUS);
    fbb_.Required(o, RobofleetStatus::VT_LOCATION);
    return o;
  }
};

inline ::flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    bool is_ok = false,
    float battery_level = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> location = 0) {
  RobofleetStatusBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_battery_level(battery_level);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_is_ok(is_ok);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *status = nullptr,
    bool is_ok = false,
    float battery_level = 0.0f,
    const char *location = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      __metadata,
      status__,
      is_ok,
      battery_level,
      location__);
}

struct RobofleetSubscription FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobofleetSubscriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TOPIC_REGEX = 6,
    VT_ACTION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *topic_regex() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOPIC_REGEX);
  }
  uint8_t action() const {
    return GetField<uint8_t>(VT_ACTION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TOPIC_REGEX) &&
           verifier.VerifyString(topic_regex()) &&
           VerifyField<uint8_t>(verifier, VT_ACTION, 1) &&
           verifier.EndTable();
  }
};

struct RobofleetSubscriptionBuilder {
  typedef RobofleetSubscription Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetSubscription::VT___METADATA, __metadata);
  }
  void add_topic_regex(::flatbuffers::Offset<::flatbuffers::String> topic_regex) {
    fbb_.AddOffset(RobofleetSubscription::VT_TOPIC_REGEX, topic_regex);
  }
  void add_action(uint8_t action) {
    fbb_.AddElement<uint8_t>(RobofleetSubscription::VT_ACTION, action, 0);
  }
  explicit RobofleetSubscriptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RobofleetSubscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RobofleetSubscription>(end);
    fbb_.Required(o, RobofleetSubscription::VT_TOPIC_REGEX);
    return o;
  }
};

inline ::flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> topic_regex = 0,
    uint8_t action = 0) {
  RobofleetSubscriptionBuilder builder_(_fbb);
  builder_.add_topic_regex(topic_regex);
  builder_.add___metadata(__metadata);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscriptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *topic_regex = nullptr,
    uint8_t action = 0) {
  auto topic_regex__ = topic_regex ? _fbb.CreateString(topic_regex) : 0;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      __metadata,
      topic_regex__,
      action);
}

struct ElevatorStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ElevatorStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FLOOR = 6,
    VT_DOOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t floor() const {
    return GetField<uint8_t>(VT_FLOOR, 0);
  }
  uint8_t door() const {
    return GetField<uint8_t>(VT_DOOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOOR, 1) &&
           verifier.EndTable();
  }
};

struct ElevatorStatusBuilder {
  typedef ElevatorStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ElevatorStatus::VT___METADATA, __metadata);
  }
  void add_floor(uint8_t floor) {
    fbb_.AddElement<uint8_t>(ElevatorStatus::VT_FLOOR, floor, 0);
  }
  void add_door(uint8_t door) {
    fbb_.AddElement<uint8_t>(ElevatorStatus::VT_DOOR, door, 0);
  }
  explicit ElevatorStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ElevatorStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ElevatorStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t floor = 0,
    uint8_t door = 0) {
  ElevatorStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_door(door);
  builder_.add_floor(floor);
  return builder_.Finish();
}

struct ElevatorCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ElevatorCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FLOOR_CMD = 6,
    VT_HOLD_DOOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t floor_cmd() const {
    return GetField<uint8_t>(VT_FLOOR_CMD, 0);
  }
  bool hold_door() const {
    return GetField<uint8_t>(VT_HOLD_DOOR, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CMD, 1) &&
           VerifyField<uint8_t>(verifier, VT_HOLD_DOOR, 1) &&
           verifier.EndTable();
  }
};

struct ElevatorCommandBuilder {
  typedef ElevatorCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ElevatorCommand::VT___METADATA, __metadata);
  }
  void add_floor_cmd(uint8_t floor_cmd) {
    fbb_.AddElement<uint8_t>(ElevatorCommand::VT_FLOOR_CMD, floor_cmd, 0);
  }
  void add_hold_door(bool hold_door) {
    fbb_.AddElement<uint8_t>(ElevatorCommand::VT_HOLD_DOOR, static_cast<uint8_t>(hold_door), 0);
  }
  explicit ElevatorCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ElevatorCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ElevatorCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t floor_cmd = 0,
    bool hold_door = false) {
  ElevatorCommandBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_hold_door(hold_door);
  builder_.add_floor_cmd(floor_cmd);
  return builder_.Finish();
}

struct ErrorReport FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_LASER_HEADER = 8,
    VT_SEVERITY_LEVEL = 10,
    VT_FAILED_SUBSYSTEM = 12,
    VT_DETAILED_ERROR_MSG = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::std_msgs::Header *laser_header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_LASER_HEADER);
  }
  uint8_t severity_level() const {
    return GetField<uint8_t>(VT_SEVERITY_LEVEL, 0);
  }
  uint8_t failed_subsystem() const {
    return GetField<uint8_t>(VT_FAILED_SUBSYSTEM, 0);
  }
  const ::flatbuffers::String *detailed_error_msg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DETAILED_ERROR_MSG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_LASER_HEADER) &&
           verifier.VerifyTable(laser_header()) &&
           VerifyField<uint8_t>(verifier, VT_SEVERITY_LEVEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_FAILED_SUBSYSTEM, 1) &&
           VerifyOffsetRequired(verifier, VT_DETAILED_ERROR_MSG) &&
           verifier.VerifyString(detailed_error_msg()) &&
           verifier.EndTable();
  }
};

struct ErrorReportBuilder {
  typedef ErrorReport Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ErrorReport::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(ErrorReport::VT_HEADER, header);
  }
  void add_laser_header(::flatbuffers::Offset<fb::std_msgs::Header> laser_header) {
    fbb_.AddOffset(ErrorReport::VT_LASER_HEADER, laser_header);
  }
  void add_severity_level(uint8_t severity_level) {
    fbb_.AddElement<uint8_t>(ErrorReport::VT_SEVERITY_LEVEL, severity_level, 0);
  }
  void add_failed_subsystem(uint8_t failed_subsystem) {
    fbb_.AddElement<uint8_t>(ErrorReport::VT_FAILED_SUBSYSTEM, failed_subsystem, 0);
  }
  void add_detailed_error_msg(::flatbuffers::Offset<::flatbuffers::String> detailed_error_msg) {
    fbb_.AddOffset(ErrorReport::VT_DETAILED_ERROR_MSG, detailed_error_msg);
  }
  explicit ErrorReportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorReport>(end);
    fbb_.Required(o, ErrorReport::VT_HEADER);
    fbb_.Required(o, ErrorReport::VT_LASER_HEADER);
    fbb_.Required(o, ErrorReport::VT_DETAILED_ERROR_MSG);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReport(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> laser_header = 0,
    uint8_t severity_level = 0,
    uint8_t failed_subsystem = 0,
    ::flatbuffers::Offset<::flatbuffers::String> detailed_error_msg = 0) {
  ErrorReportBuilder builder_(_fbb);
  builder_.add_detailed_error_msg(detailed_error_msg);
  builder_.add_laser_header(laser_header);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_failed_subsystem(failed_subsystem);
  builder_.add_severity_level(severity_level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> laser_header = 0,
    uint8_t severity_level = 0,
    uint8_t failed_subsystem = 0,
    const char *detailed_error_msg = nullptr) {
  auto detailed_error_msg__ = detailed_error_msg ? _fbb.CreateString(detailed_error_msg) : 0;
  return fb::amrl_msgs::CreateErrorReport(
      _fbb,
      __metadata,
      header,
      laser_header,
      severity_level,
      failed_subsystem,
      detailed_error_msg__);
}

struct Pose2Df FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Pose2DfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_THETA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float theta() const {
    return GetField<float>(VT_THETA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_THETA, 4) &&
           verifier.EndTable();
  }
};

struct Pose2DfBuilder {
  typedef Pose2Df Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose2Df::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Pose2Df::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Pose2Df::VT_Y, y, 0.0f);
  }
  void add_theta(float theta) {
    fbb_.AddElement<float>(Pose2Df::VT_THETA, theta, 0.0f);
  }
  explicit Pose2DfBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pose2Df> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pose2Df>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pose2Df> CreatePose2Df(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f,
    float theta = 0.0f) {
  Pose2DfBuilder builder_(_fbb);
  builder_.add_theta(theta);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Localization2DMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Localization2DMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8,
    VT_MAP = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::amrl_msgs::Pose2Df *pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_POSE);
  }
  const ::flatbuffers::String *map() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyString(map()) &&
           verifier.EndTable();
  }
};

struct Localization2DMsgBuilder {
  typedef Localization2DMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Localization2DMsg::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Localization2DMsg::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose) {
    fbb_.AddOffset(Localization2DMsg::VT_POSE, pose);
  }
  void add_map(::flatbuffers::Offset<::flatbuffers::String> map) {
    fbb_.AddOffset(Localization2DMsg::VT_MAP, map);
  }
  explicit Localization2DMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Localization2DMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Localization2DMsg>(end);
    fbb_.Required(o, Localization2DMsg::VT_HEADER);
    fbb_.Required(o, Localization2DMsg::VT_POSE);
    fbb_.Required(o, Localization2DMsg::VT_MAP);
    return o;
  }
};

inline ::flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map = 0) {
  Localization2DMsgBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    const char *map = nullptr) {
  auto map__ = map ? _fbb.CreateString(map) : 0;
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      __metadata,
      header,
      pose,
      map__);
}

struct PathVisualization FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PathVisualizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CURVATURE = 6,
    VT_DISTANCE = 8,
    VT_CLEARANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float curvature() const {
    return GetField<float>(VT_CURVATURE, 0.0f);
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  float clearance() const {
    return GetField<float>(VT_CLEARANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_CURVATURE, 4) &&
           VerifyField<float>(verifier, VT_DISTANCE, 4) &&
           VerifyField<float>(verifier, VT_CLEARANCE, 4) &&
           verifier.EndTable();
  }
};

struct PathVisualizationBuilder {
  typedef PathVisualization Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PathVisualization::VT___METADATA, __metadata);
  }
  void add_curvature(float curvature) {
    fbb_.AddElement<float>(PathVisualization::VT_CURVATURE, curvature, 0.0f);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(PathVisualization::VT_DISTANCE, distance, 0.0f);
  }
  void add_clearance(float clearance) {
    fbb_.AddElement<float>(PathVisualization::VT_CLEARANCE, clearance, 0.0f);
  }
  explicit PathVisualizationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PathVisualization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PathVisualization>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PathVisualization> CreatePathVisualization(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float curvature = 0.0f,
    float distance = 0.0f,
    float clearance = 0.0f) {
  PathVisualizationBuilder builder_(_fbb);
  builder_.add_clearance(clearance);
  builder_.add_distance(distance);
  builder_.add_curvature(curvature);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct Point2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Point2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
};

struct Point2DBuilder {
  typedef Point2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point2D::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Point2D::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Point2D::VT_Y, y, 0.0f);
  }
  explicit Point2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Point2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Point2D>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Point2D> CreatePoint2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f) {
  Point2DBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct ColoredPoint2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColoredPoint2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POINT = 6,
    VT_COLOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *point() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_POINT);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POINT) &&
           verifier.VerifyTable(point()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct ColoredPoint2DBuilder {
  typedef ColoredPoint2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredPoint2D::VT___METADATA, __metadata);
  }
  void add_point(::flatbuffers::Offset<fb::amrl_msgs::Point2D> point) {
    fbb_.AddOffset(ColoredPoint2D::VT_POINT, point);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredPoint2D::VT_COLOR, color, 0);
  }
  explicit ColoredPoint2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColoredPoint2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColoredPoint2D>(end);
    fbb_.Required(o, ColoredPoint2D::VT_POINT);
    return o;
  }
};

inline ::flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> point = 0,
    uint32_t color = 0) {
  ColoredPoint2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_point(point);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct ColoredLine2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColoredLine2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_P0 = 6,
    VT_P1 = 8,
    VT_COLOR = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *p0() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P0);
  }
  const fb::amrl_msgs::Point2D *p1() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P1);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_P0) &&
           verifier.VerifyTable(p0()) &&
           VerifyOffsetRequired(verifier, VT_P1) &&
           verifier.VerifyTable(p1()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct ColoredLine2DBuilder {
  typedef ColoredLine2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredLine2D::VT___METADATA, __metadata);
  }
  void add_p0(::flatbuffers::Offset<fb::amrl_msgs::Point2D> p0) {
    fbb_.AddOffset(ColoredLine2D::VT_P0, p0);
  }
  void add_p1(::flatbuffers::Offset<fb::amrl_msgs::Point2D> p1) {
    fbb_.AddOffset(ColoredLine2D::VT_P1, p1);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredLine2D::VT_COLOR, color, 0);
  }
  explicit ColoredLine2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColoredLine2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColoredLine2D>(end);
    fbb_.Required(o, ColoredLine2D::VT_P0);
    fbb_.Required(o, ColoredLine2D::VT_P1);
    return o;
  }
};

inline ::flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> p0 = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> p1 = 0,
    uint32_t color = 0) {
  ColoredLine2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_p1(p1);
  builder_.add_p0(p0);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct ColoredArc2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColoredArc2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12,
    VT_COLOR = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *center() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_CENTER) &&
           verifier.VerifyTable(center()) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct ColoredArc2DBuilder {
  typedef ColoredArc2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredArc2D::VT___METADATA, __metadata);
  }
  void add_center(::flatbuffers::Offset<fb::amrl_msgs::Point2D> center) {
    fbb_.AddOffset(ColoredArc2D::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ColoredArc2D::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_END_ANGLE, end_angle, 0.0f);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredArc2D::VT_COLOR, color, 0);
  }
  explicit ColoredArc2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColoredArc2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColoredArc2D>(end);
    fbb_.Required(o, ColoredArc2D::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> center = 0,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f,
    uint32_t color = 0) {
  ColoredArc2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct VisualizationMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VisualizationMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NS = 8,
    VT_PARTICLES = 10,
    VT_PATH_OPTIONS = 12,
    VT_POINTS = 14,
    VT_LINES = 16,
    VT_ARCS = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_PARTICLES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *>(VT_PATH_OPTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *>(VT_POINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *>(VT_LINES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *>(VT_ARCS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyOffsetRequired(verifier, VT_PARTICLES) &&
           verifier.VerifyVector(particles()) &&
           verifier.VerifyVectorOfTables(particles()) &&
           VerifyOffsetRequired(verifier, VT_PATH_OPTIONS) &&
           verifier.VerifyVector(path_options()) &&
           verifier.VerifyVectorOfTables(path_options()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffsetRequired(verifier, VT_ARCS) &&
           verifier.VerifyVector(arcs()) &&
           verifier.VerifyVectorOfTables(arcs()) &&
           verifier.EndTable();
  }
};

struct VisualizationMsgBuilder {
  typedef VisualizationMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(VisualizationMsg::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(VisualizationMsg::VT_HEADER, header);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(VisualizationMsg::VT_NS, ns);
  }
  void add_particles(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles) {
    fbb_.AddOffset(VisualizationMsg::VT_PARTICLES, particles);
  }
  void add_path_options(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options) {
    fbb_.AddOffset(VisualizationMsg::VT_PATH_OPTIONS, path_options);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points) {
    fbb_.AddOffset(VisualizationMsg::VT_POINTS, points);
  }
  void add_lines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines) {
    fbb_.AddOffset(VisualizationMsg::VT_LINES, lines);
  }
  void add_arcs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs) {
    fbb_.AddOffset(VisualizationMsg::VT_ARCS, arcs);
  }
  explicit VisualizationMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VisualizationMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VisualizationMsg>(end);
    fbb_.Required(o, VisualizationMsg::VT_HEADER);
    fbb_.Required(o, VisualizationMsg::VT_NS);
    fbb_.Required(o, VisualizationMsg::VT_PARTICLES);
    fbb_.Required(o, VisualizationMsg::VT_PATH_OPTIONS);
    fbb_.Required(o, VisualizationMsg::VT_POINTS);
    fbb_.Required(o, VisualizationMsg::VT_LINES);
    fbb_.Required(o, VisualizationMsg::VT_ARCS);
    return o;
  }
};

inline ::flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs = 0) {
  VisualizationMsgBuilder builder_(_fbb);
  builder_.add_arcs(arcs);
  builder_.add_lines(lines);
  builder_.add_points(points);
  builder_.add_path_options(path_options);
  builder_.add_particles(particles);
  builder_.add_ns(ns);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *ns = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto particles__ = particles ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*particles) : 0;
  auto path_options__ = path_options ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>(*path_options) : 0;
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>(*points) : 0;
  auto lines__ = lines ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>(*lines) : 0;
  auto arcs__ = arcs ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>(*arcs) : 0;
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      __metadata,
      header,
      ns__,
      particles__,
      path_options__,
      points__,
      lines__,
      arcs__);
}

}  // namespace amrl_msgs

namespace nav_msgs {

struct Odometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OdometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_POSE = 10,
    VT_TWIST = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *child_frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  const fb::geometry_msgs::TwistWithCovariance *twist() const {
    return GetPointer<const fb::geometry_msgs::TwistWithCovariance *>(VT_TWIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
};

struct OdometryBuilder {
  typedef Odometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Odometry::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Odometry::VT_HEADER, header);
  }
  void add_child_frame_id(::flatbuffers::Offset<::flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(Odometry::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(Odometry::VT_POSE, pose);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist) {
    fbb_.AddOffset(Odometry::VT_TWIST, twist);
  }
  explicit OdometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Odometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Odometry>(end);
    fbb_.Required(o, Odometry::VT_HEADER);
    fbb_.Required(o, Odometry::VT_CHILD_FRAME_ID);
    fbb_.Required(o, Odometry::VT_POSE);
    fbb_.Required(o, Odometry::VT_TWIST);
    return o;
  }
};

inline ::flatbuffers::Offset<Odometry> CreateOdometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> child_frame_id = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  OdometryBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_pose(pose);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Odometry> CreateOdometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      pose,
      twist);
}

}  // namespace nav_msgs

namespace std_srvs {

struct Empty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REQUEST = 6,
    VT_RESPONSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_srvs::EmptyRequest *request() const {
    return GetPointer<const fb::std_srvs::EmptyRequest *>(VT_REQUEST);
  }
  const fb::std_srvs::EmptyResponse *response() const {
    return GetPointer<const fb::std_srvs::EmptyResponse *>(VT_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyTable(response()) &&
           verifier.EndTable();
  }
};

struct EmptyBuilder {
  typedef Empty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Empty::VT___METADATA, __metadata);
  }
  void add_request(::flatbuffers::Offset<fb::std_srvs::EmptyRequest> request) {
    fbb_.AddOffset(Empty::VT_REQUEST, request);
  }
  void add_response(::flatbuffers::Offset<fb::std_srvs::EmptyResponse> response) {
    fbb_.AddOffset(Empty::VT_RESPONSE, response);
  }
  explicit EmptyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Empty> CreateEmpty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_srvs::EmptyRequest> request = 0,
    ::flatbuffers::Offset<fb::std_srvs::EmptyResponse> response = 0) {
  EmptyBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_request(request);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct EmptyRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyRequestBuilder {
  typedef EmptyRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EmptyRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmptyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmptyRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmptyRequest> CreateEmptyRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EmptyResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyResponseBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyResponseBuilder {
  typedef EmptyResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EmptyResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmptyResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmptyResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmptyResponse> CreateEmptyResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Trigger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriggerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REQUEST = 6,
    VT_RESPONSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_srvs::TriggerRequest *request() const {
    return GetPointer<const fb::std_srvs::TriggerRequest *>(VT_REQUEST);
  }
  const fb::std_srvs::TriggerResponse *response() const {
    return GetPointer<const fb::std_srvs::TriggerResponse *>(VT_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyTable(response()) &&
           verifier.EndTable();
  }
};

struct TriggerBuilder {
  typedef Trigger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Trigger::VT___METADATA, __metadata);
  }
  void add_request(::flatbuffers::Offset<fb::std_srvs::TriggerRequest> request) {
    fbb_.AddOffset(Trigger::VT_REQUEST, request);
  }
  void add_response(::flatbuffers::Offset<fb::std_srvs::TriggerResponse> response) {
    fbb_.AddOffset(Trigger::VT_RESPONSE, response);
  }
  explicit TriggerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Trigger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Trigger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Trigger> CreateTrigger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_srvs::TriggerRequest> request = 0,
    ::flatbuffers::Offset<fb::std_srvs::TriggerResponse> response = 0) {
  TriggerBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_request(request);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct TriggerRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriggerRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TriggerRequestBuilder {
  typedef TriggerRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TriggerRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TriggerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TriggerRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TriggerRequest> CreateTriggerRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TriggerRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TriggerResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriggerResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct TriggerResponseBuilder {
  typedef TriggerResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(TriggerResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(TriggerResponse::VT_MESSAGE, message);
  }
  explicit TriggerResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TriggerResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TriggerResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TriggerResponse> CreateTriggerResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  TriggerResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TriggerResponse> CreateTriggerResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return fb::std_srvs::CreateTriggerResponse(
      _fbb,
      success,
      message__);
}

struct SetBool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetBoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REQUEST = 6,
    VT_RESPONSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_srvs::SetBoolRequest *request() const {
    return GetPointer<const fb::std_srvs::SetBoolRequest *>(VT_REQUEST);
  }
  const fb::std_srvs::SetBoolResponse *response() const {
    return GetPointer<const fb::std_srvs::SetBoolResponse *>(VT_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyTable(response()) &&
           verifier.EndTable();
  }
};

struct SetBoolBuilder {
  typedef SetBool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SetBool::VT___METADATA, __metadata);
  }
  void add_request(::flatbuffers::Offset<fb::std_srvs::SetBoolRequest> request) {
    fbb_.AddOffset(SetBool::VT_REQUEST, request);
  }
  void add_response(::flatbuffers::Offset<fb::std_srvs::SetBoolResponse> response) {
    fbb_.AddOffset(SetBool::VT_RESPONSE, response);
  }
  explicit SetBoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetBool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetBool> CreateSetBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_srvs::SetBoolRequest> request = 0,
    ::flatbuffers::Offset<fb::std_srvs::SetBoolResponse> response = 0) {
  SetBoolBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_request(request);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct SetBoolRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetBoolRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  bool data() const {
    return GetField<uint8_t>(VT_DATA, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
};

struct SetBoolRequestBuilder {
  typedef SetBoolRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(bool data) {
    fbb_.AddElement<uint8_t>(SetBoolRequest::VT_DATA, static_cast<uint8_t>(data), 0);
  }
  explicit SetBoolRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetBoolRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetBoolRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetBoolRequest> CreateSetBoolRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool data = false) {
  SetBoolRequestBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct SetBoolResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetBoolResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct SetBoolResponseBuilder {
  typedef SetBoolResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SetBoolResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(SetBoolResponse::VT_MESSAGE, message);
  }
  explicit SetBoolResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetBoolResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetBoolResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetBoolResponse> CreateSetBoolResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  SetBoolResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetBoolResponse> CreateSetBoolResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return fb::std_srvs::CreateSetBoolResponse(
      _fbb,
      success,
      message__);
}

}  // namespace std_srvs

namespace aerialcore_common {

struct ConfigMission FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigMissionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REQUEST = 6,
    VT_RESPONSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::aerialcore_common::ConfigMissionRequest *request() const {
    return GetPointer<const fb::aerialcore_common::ConfigMissionRequest *>(VT_REQUEST);
  }
  const fb::aerialcore_common::ConfigMissionResponse *response() const {
    return GetPointer<const fb::aerialcore_common::ConfigMissionResponse *>(VT_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyTable(response()) &&
           verifier.EndTable();
  }
};

struct ConfigMissionBuilder {
  typedef ConfigMission Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ConfigMission::VT___METADATA, __metadata);
  }
  void add_request(::flatbuffers::Offset<fb::aerialcore_common::ConfigMissionRequest> request) {
    fbb_.AddOffset(ConfigMission::VT_REQUEST, request);
  }
  void add_response(::flatbuffers::Offset<fb::aerialcore_common::ConfigMissionResponse> response) {
    fbb_.AddOffset(ConfigMission::VT_RESPONSE, response);
  }
  explicit ConfigMissionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigMission> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigMission>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigMission> CreateConfigMission(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::aerialcore_common::ConfigMissionRequest> request = 0,
    ::flatbuffers::Offset<fb::aerialcore_common::ConfigMissionResponse> response = 0) {
  ConfigMissionBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_request(request);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct ConfigMissionRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigMissionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UAV_ID = 4,
    VT_MISSION_ID = 6,
    VT_MISSION_TYPE = 8,
    VT_WAYPOINT = 10,
    VT_RADIUS = 12,
    VT_MAXVEL = 14,
    VT_IDLEVEL = 16,
    VT_YAW = 18,
    VT_GIMBALPITCH = 20,
    VT_SPEED = 22,
    VT_YAWMODE = 24,
    VT_TRACEMODE = 26,
    VT_GIMBALPITCHMODE = 28,
    VT_FINISHACTION = 30,
    VT_COMMANDLIST = 32,
    VT_COMMANDPARAMETER = 34
  };
  const ::flatbuffers::String *uav_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UAV_ID);
  }
  const ::flatbuffers::String *mission_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSION_ID);
  }
  uint8_t mission_type() const {
    return GetField<uint8_t>(VT_MISSION_TYPE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::NavSatFix>> *waypoint() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::NavSatFix>> *>(VT_WAYPOINT);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  double maxVel() const {
    return GetField<double>(VT_MAXVEL, 0.0);
  }
  double idleVel() const {
    return GetField<double>(VT_IDLEVEL, 0.0);
  }
  const ::flatbuffers::Vector<float> *yaw() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YAW);
  }
  const ::flatbuffers::Vector<float> *gimbalPitch() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_GIMBALPITCH);
  }
  const ::flatbuffers::Vector<float> *speed() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SPEED);
  }
  uint8_t yawMode() const {
    return GetField<uint8_t>(VT_YAWMODE, 0);
  }
  uint8_t traceMode() const {
    return GetField<uint8_t>(VT_TRACEMODE, 0);
  }
  uint8_t gimbalPitchMode() const {
    return GetField<uint8_t>(VT_GIMBALPITCHMODE, 0);
  }
  uint8_t finishAction() const {
    return GetField<uint8_t>(VT_FINISHACTION, 0);
  }
  const ::flatbuffers::Vector<float> *commandList() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_COMMANDLIST);
  }
  const ::flatbuffers::Vector<float> *commandParameter() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_COMMANDPARAMETER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UAV_ID) &&
           verifier.VerifyString(uav_id()) &&
           VerifyOffset(verifier, VT_MISSION_ID) &&
           verifier.VerifyString(mission_id()) &&
           VerifyField<uint8_t>(verifier, VT_MISSION_TYPE, 1) &&
           VerifyOffset(verifier, VT_WAYPOINT) &&
           verifier.VerifyVector(waypoint()) &&
           verifier.VerifyVectorOfTables(waypoint()) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           VerifyField<double>(verifier, VT_MAXVEL, 8) &&
           VerifyField<double>(verifier, VT_IDLEVEL, 8) &&
           VerifyOffset(verifier, VT_YAW) &&
           verifier.VerifyVector(yaw()) &&
           VerifyOffset(verifier, VT_GIMBALPITCH) &&
           verifier.VerifyVector(gimbalPitch()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyVector(speed()) &&
           VerifyField<uint8_t>(verifier, VT_YAWMODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACEMODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_GIMBALPITCHMODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FINISHACTION, 1) &&
           VerifyOffset(verifier, VT_COMMANDLIST) &&
           verifier.VerifyVector(commandList()) &&
           VerifyOffset(verifier, VT_COMMANDPARAMETER) &&
           verifier.VerifyVector(commandParameter()) &&
           verifier.EndTable();
  }
};

struct ConfigMissionRequestBuilder {
  typedef ConfigMissionRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uav_id(::flatbuffers::Offset<::flatbuffers::String> uav_id) {
    fbb_.AddOffset(ConfigMissionRequest::VT_UAV_ID, uav_id);
  }
  void add_mission_id(::flatbuffers::Offset<::flatbuffers::String> mission_id) {
    fbb_.AddOffset(ConfigMissionRequest::VT_MISSION_ID, mission_id);
  }
  void add_mission_type(uint8_t mission_type) {
    fbb_.AddElement<uint8_t>(ConfigMissionRequest::VT_MISSION_TYPE, mission_type, 0);
  }
  void add_waypoint(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::NavSatFix>>> waypoint) {
    fbb_.AddOffset(ConfigMissionRequest::VT_WAYPOINT, waypoint);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(ConfigMissionRequest::VT_RADIUS, radius, 0.0);
  }
  void add_maxVel(double maxVel) {
    fbb_.AddElement<double>(ConfigMissionRequest::VT_MAXVEL, maxVel, 0.0);
  }
  void add_idleVel(double idleVel) {
    fbb_.AddElement<double>(ConfigMissionRequest::VT_IDLEVEL, idleVel, 0.0);
  }
  void add_yaw(::flatbuffers::Offset<::flatbuffers::Vector<float>> yaw) {
    fbb_.AddOffset(ConfigMissionRequest::VT_YAW, yaw);
  }
  void add_gimbalPitch(::flatbuffers::Offset<::flatbuffers::Vector<float>> gimbalPitch) {
    fbb_.AddOffset(ConfigMissionRequest::VT_GIMBALPITCH, gimbalPitch);
  }
  void add_speed(::flatbuffers::Offset<::flatbuffers::Vector<float>> speed) {
    fbb_.AddOffset(ConfigMissionRequest::VT_SPEED, speed);
  }
  void add_yawMode(uint8_t yawMode) {
    fbb_.AddElement<uint8_t>(ConfigMissionRequest::VT_YAWMODE, yawMode, 0);
  }
  void add_traceMode(uint8_t traceMode) {
    fbb_.AddElement<uint8_t>(ConfigMissionRequest::VT_TRACEMODE, traceMode, 0);
  }
  void add_gimbalPitchMode(uint8_t gimbalPitchMode) {
    fbb_.AddElement<uint8_t>(ConfigMissionRequest::VT_GIMBALPITCHMODE, gimbalPitchMode, 0);
  }
  void add_finishAction(uint8_t finishAction) {
    fbb_.AddElement<uint8_t>(ConfigMissionRequest::VT_FINISHACTION, finishAction, 0);
  }
  void add_commandList(::flatbuffers::Offset<::flatbuffers::Vector<float>> commandList) {
    fbb_.AddOffset(ConfigMissionRequest::VT_COMMANDLIST, commandList);
  }
  void add_commandParameter(::flatbuffers::Offset<::flatbuffers::Vector<float>> commandParameter) {
    fbb_.AddOffset(ConfigMissionRequest::VT_COMMANDPARAMETER, commandParameter);
  }
  explicit ConfigMissionRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigMissionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigMissionRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigMissionRequest> CreateConfigMissionRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uav_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mission_id = 0,
    uint8_t mission_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::NavSatFix>>> waypoint = 0,
    double radius = 0.0,
    double maxVel = 0.0,
    double idleVel = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> yaw = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> gimbalPitch = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> speed = 0,
    uint8_t yawMode = 0,
    uint8_t traceMode = 0,
    uint8_t gimbalPitchMode = 0,
    uint8_t finishAction = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> commandList = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> commandParameter = 0) {
  ConfigMissionRequestBuilder builder_(_fbb);
  builder_.add_idleVel(idleVel);
  builder_.add_maxVel(maxVel);
  builder_.add_radius(radius);
  builder_.add_commandParameter(commandParameter);
  builder_.add_commandList(commandList);
  builder_.add_speed(speed);
  builder_.add_gimbalPitch(gimbalPitch);
  builder_.add_yaw(yaw);
  builder_.add_waypoint(waypoint);
  builder_.add_mission_id(mission_id);
  builder_.add_uav_id(uav_id);
  builder_.add_finishAction(finishAction);
  builder_.add_gimbalPitchMode(gimbalPitchMode);
  builder_.add_traceMode(traceMode);
  builder_.add_yawMode(yawMode);
  builder_.add_mission_type(mission_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigMissionRequest> CreateConfigMissionRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uav_id = nullptr,
    const char *mission_id = nullptr,
    uint8_t mission_type = 0,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::NavSatFix>> *waypoint = nullptr,
    double radius = 0.0,
    double maxVel = 0.0,
    double idleVel = 0.0,
    const std::vector<float> *yaw = nullptr,
    const std::vector<float> *gimbalPitch = nullptr,
    const std::vector<float> *speed = nullptr,
    uint8_t yawMode = 0,
    uint8_t traceMode = 0,
    uint8_t gimbalPitchMode = 0,
    uint8_t finishAction = 0,
    const std::vector<float> *commandList = nullptr,
    const std::vector<float> *commandParameter = nullptr) {
  auto uav_id__ = uav_id ? _fbb.CreateString(uav_id) : 0;
  auto mission_id__ = mission_id ? _fbb.CreateString(mission_id) : 0;
  auto waypoint__ = waypoint ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::NavSatFix>>(*waypoint) : 0;
  auto yaw__ = yaw ? _fbb.CreateVector<float>(*yaw) : 0;
  auto gimbalPitch__ = gimbalPitch ? _fbb.CreateVector<float>(*gimbalPitch) : 0;
  auto speed__ = speed ? _fbb.CreateVector<float>(*speed) : 0;
  auto commandList__ = commandList ? _fbb.CreateVector<float>(*commandList) : 0;
  auto commandParameter__ = commandParameter ? _fbb.CreateVector<float>(*commandParameter) : 0;
  return fb::aerialcore_common::CreateConfigMissionRequest(
      _fbb,
      uav_id__,
      mission_id__,
      mission_type,
      waypoint__,
      radius,
      maxVel,
      idleVel,
      yaw__,
      gimbalPitch__,
      speed__,
      yawMode,
      traceMode,
      gimbalPitchMode,
      finishAction,
      commandList__,
      commandParameter__);
}

struct ConfigMissionResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigMissionResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
};

struct ConfigMissionResponseBuilder {
  typedef ConfigMissionResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ConfigMissionResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ConfigMissionResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigMissionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigMissionResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigMissionResponse> CreateConfigMissionResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ConfigMissionResponseBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct eventService FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef eventServiceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REQUEST = 6,
    VT_RESPONSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::aerialcore_common::eventRequest *request() const {
    return GetPointer<const fb::aerialcore_common::eventRequest *>(VT_REQUEST);
  }
  const fb::aerialcore_common::eventResponse *response() const {
    return GetPointer<const fb::aerialcore_common::eventResponse *>(VT_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyTable(response()) &&
           verifier.EndTable();
  }
};

struct eventServiceBuilder {
  typedef eventService Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(eventService::VT___METADATA, __metadata);
  }
  void add_request(::flatbuffers::Offset<fb::aerialcore_common::eventRequest> request) {
    fbb_.AddOffset(eventService::VT_REQUEST, request);
  }
  void add_response(::flatbuffers::Offset<fb::aerialcore_common::eventResponse> response) {
    fbb_.AddOffset(eventService::VT_RESPONSE, response);
  }
  explicit eventServiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<eventService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<eventService>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<eventService> CreateeventService(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::aerialcore_common::eventRequest> request = 0,
    ::flatbuffers::Offset<fb::aerialcore_common::eventResponse> response = 0) {
  eventServiceBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_request(request);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

struct eventRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef eventRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UAV_ID = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *uav_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UAV_ID);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_UAV_ID) &&
           verifier.VerifyString(uav_id()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct eventRequestBuilder {
  typedef eventRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(eventRequest::VT___METADATA, __metadata);
  }
  void add_uav_id(::flatbuffers::Offset<::flatbuffers::String> uav_id) {
    fbb_.AddOffset(eventRequest::VT_UAV_ID, uav_id);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(eventRequest::VT_DATA, data);
  }
  explicit eventRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<eventRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<eventRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<eventRequest> CreateeventRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> uav_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  eventRequestBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_uav_id(uav_id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<eventRequest> CreateeventRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *uav_id = nullptr,
    const char *data = nullptr) {
  auto uav_id__ = uav_id ? _fbb.CreateString(uav_id) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return fb::aerialcore_common::CreateeventRequest(
      _fbb,
      __metadata,
      uav_id__,
      data__);
}

struct eventResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef eventResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_MSG = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *msg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.VerifyString(msg()) &&
           verifier.EndTable();
  }
};

struct eventResponseBuilder {
  typedef eventResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(eventResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(eventResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_msg(::flatbuffers::Offset<::flatbuffers::String> msg) {
    fbb_.AddOffset(eventResponse::VT_MSG, msg);
  }
  explicit eventResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<eventResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<eventResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<eventResponse> CreateeventResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> msg = 0) {
  eventResponseBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<eventResponse> CreateeventResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    const char *msg = nullptr) {
  auto msg__ = msg ? _fbb.CreateString(msg) : 0;
  return fb::aerialcore_common::CreateeventResponse(
      _fbb,
      __metadata,
      success,
      msg__);
}

}  // namespace aerialcore_common

namespace dji_osdk_ros {

struct ObstacleInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObstacleInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_DOWN = 8,
    VT_FRONT = 10,
    VT_RIGHT = 12,
    VT_BACK = 14,
    VT_LEFT = 16,
    VT_UP = 18,
    VT_HEALT_NOT_WORKING = 20,
    VT_HEALT_WORKING = 22,
    VT_DOWN_HEALTH = 24,
    VT_FRONT_HEALTH = 26,
    VT_RIGHT_HEALTH = 28,
    VT_BACK_HEALTH = 30,
    VT_LEFT_HEALTH = 32,
    VT_UP_HEALTH = 34
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float down() const {
    return GetField<float>(VT_DOWN, 0.0f);
  }
  float front() const {
    return GetField<float>(VT_FRONT, 0.0f);
  }
  float right() const {
    return GetField<float>(VT_RIGHT, 0.0f);
  }
  float back() const {
    return GetField<float>(VT_BACK, 0.0f);
  }
  float left() const {
    return GetField<float>(VT_LEFT, 0.0f);
  }
  float up() const {
    return GetField<float>(VT_UP, 0.0f);
  }
  uint8_t HEALT_NOT_WORKING() const {
    return GetField<uint8_t>(VT_HEALT_NOT_WORKING, 0);
  }
  uint8_t HEALT_WORKING() const {
    return GetField<uint8_t>(VT_HEALT_WORKING, 1);
  }
  uint8_t down_health() const {
    return GetField<uint8_t>(VT_DOWN_HEALTH, 0);
  }
  uint8_t front_health() const {
    return GetField<uint8_t>(VT_FRONT_HEALTH, 0);
  }
  uint8_t right_health() const {
    return GetField<uint8_t>(VT_RIGHT_HEALTH, 0);
  }
  uint8_t back_health() const {
    return GetField<uint8_t>(VT_BACK_HEALTH, 0);
  }
  uint8_t left_health() const {
    return GetField<uint8_t>(VT_LEFT_HEALTH, 0);
  }
  uint8_t up_health() const {
    return GetField<uint8_t>(VT_UP_HEALTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_DOWN, 4) &&
           VerifyField<float>(verifier, VT_FRONT, 4) &&
           VerifyField<float>(verifier, VT_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_BACK, 4) &&
           VerifyField<float>(verifier, VT_LEFT, 4) &&
           VerifyField<float>(verifier, VT_UP, 4) &&
           VerifyField<uint8_t>(verifier, VT_HEALT_NOT_WORKING, 1) &&
           VerifyField<uint8_t>(verifier, VT_HEALT_WORKING, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOWN_HEALTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_FRONT_HEALTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_RIGHT_HEALTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_BACK_HEALTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEFT_HEALTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_UP_HEALTH, 1) &&
           verifier.EndTable();
  }
};

struct ObstacleInfoBuilder {
  typedef ObstacleInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ObstacleInfo::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(ObstacleInfo::VT_HEADER, header);
  }
  void add_down(float down) {
    fbb_.AddElement<float>(ObstacleInfo::VT_DOWN, down, 0.0f);
  }
  void add_front(float front) {
    fbb_.AddElement<float>(ObstacleInfo::VT_FRONT, front, 0.0f);
  }
  void add_right(float right) {
    fbb_.AddElement<float>(ObstacleInfo::VT_RIGHT, right, 0.0f);
  }
  void add_back(float back) {
    fbb_.AddElement<float>(ObstacleInfo::VT_BACK, back, 0.0f);
  }
  void add_left(float left) {
    fbb_.AddElement<float>(ObstacleInfo::VT_LEFT, left, 0.0f);
  }
  void add_up(float up) {
    fbb_.AddElement<float>(ObstacleInfo::VT_UP, up, 0.0f);
  }
  void add_HEALT_NOT_WORKING(uint8_t HEALT_NOT_WORKING) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_HEALT_NOT_WORKING, HEALT_NOT_WORKING, 0);
  }
  void add_HEALT_WORKING(uint8_t HEALT_WORKING) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_HEALT_WORKING, HEALT_WORKING, 1);
  }
  void add_down_health(uint8_t down_health) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_DOWN_HEALTH, down_health, 0);
  }
  void add_front_health(uint8_t front_health) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_FRONT_HEALTH, front_health, 0);
  }
  void add_right_health(uint8_t right_health) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_RIGHT_HEALTH, right_health, 0);
  }
  void add_back_health(uint8_t back_health) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_BACK_HEALTH, back_health, 0);
  }
  void add_left_health(uint8_t left_health) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_LEFT_HEALTH, left_health, 0);
  }
  void add_up_health(uint8_t up_health) {
    fbb_.AddElement<uint8_t>(ObstacleInfo::VT_UP_HEALTH, up_health, 0);
  }
  explicit ObstacleInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObstacleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObstacleInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObstacleInfo> CreateObstacleInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float down = 0.0f,
    float front = 0.0f,
    float right = 0.0f,
    float back = 0.0f,
    float left = 0.0f,
    float up = 0.0f,
    uint8_t HEALT_NOT_WORKING = 0,
    uint8_t HEALT_WORKING = 1,
    uint8_t down_health = 0,
    uint8_t front_health = 0,
    uint8_t right_health = 0,
    uint8_t back_health = 0,
    uint8_t left_health = 0,
    uint8_t up_health = 0) {
  ObstacleInfoBuilder builder_(_fbb);
  builder_.add_up(up);
  builder_.add_left(left);
  builder_.add_back(back);
  builder_.add_right(right);
  builder_.add_front(front);
  builder_.add_down(down);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_up_health(up_health);
  builder_.add_left_health(left_health);
  builder_.add_back_health(back_health);
  builder_.add_right_health(right_health);
  builder_.add_front_health(front_health);
  builder_.add_down_health(down_health);
  builder_.add_HEALT_WORKING(HEALT_WORKING);
  builder_.add_HEALT_NOT_WORKING(HEALT_NOT_WORKING);
  return builder_.Finish();
}

struct WaypointV2MissionStatePush FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WaypointV2MissionStatePushBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_COMMONDATAVERSION = 6,
    VT_COMMONDATALEN = 8,
    VT_CURWAYPOINTINDEX = 10,
    VT_STATE = 12,
    VT_VELOCITY = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t commonDataVersion() const {
    return GetField<uint8_t>(VT_COMMONDATAVERSION, 0);
  }
  uint16_t commonDataLen() const {
    return GetField<uint16_t>(VT_COMMONDATALEN, 0);
  }
  uint16_t curWaypointIndex() const {
    return GetField<uint16_t>(VT_CURWAYPOINTINDEX, 0);
  }
  uint8_t state() const {
    return GetField<uint8_t>(VT_STATE, 0);
  }
  uint16_t velocity() const {
    return GetField<uint16_t>(VT_VELOCITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_COMMONDATAVERSION, 1) &&
           VerifyField<uint16_t>(verifier, VT_COMMONDATALEN, 2) &&
           VerifyField<uint16_t>(verifier, VT_CURWAYPOINTINDEX, 2) &&
           VerifyField<uint8_t>(verifier, VT_STATE, 1) &&
           VerifyField<uint16_t>(verifier, VT_VELOCITY, 2) &&
           verifier.EndTable();
  }
};

struct WaypointV2MissionStatePushBuilder {
  typedef WaypointV2MissionStatePush Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(WaypointV2MissionStatePush::VT___METADATA, __metadata);
  }
  void add_commonDataVersion(uint8_t commonDataVersion) {
    fbb_.AddElement<uint8_t>(WaypointV2MissionStatePush::VT_COMMONDATAVERSION, commonDataVersion, 0);
  }
  void add_commonDataLen(uint16_t commonDataLen) {
    fbb_.AddElement<uint16_t>(WaypointV2MissionStatePush::VT_COMMONDATALEN, commonDataLen, 0);
  }
  void add_curWaypointIndex(uint16_t curWaypointIndex) {
    fbb_.AddElement<uint16_t>(WaypointV2MissionStatePush::VT_CURWAYPOINTINDEX, curWaypointIndex, 0);
  }
  void add_state(uint8_t state) {
    fbb_.AddElement<uint8_t>(WaypointV2MissionStatePush::VT_STATE, state, 0);
  }
  void add_velocity(uint16_t velocity) {
    fbb_.AddElement<uint16_t>(WaypointV2MissionStatePush::VT_VELOCITY, velocity, 0);
  }
  explicit WaypointV2MissionStatePushBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WaypointV2MissionStatePush> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WaypointV2MissionStatePush>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WaypointV2MissionStatePush> CreateWaypointV2MissionStatePush(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t commonDataVersion = 0,
    uint16_t commonDataLen = 0,
    uint16_t curWaypointIndex = 0,
    uint8_t state = 0,
    uint16_t velocity = 0) {
  WaypointV2MissionStatePushBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_velocity(velocity);
  builder_.add_curWaypointIndex(curWaypointIndex);
  builder_.add_commonDataLen(commonDataLen);
  builder_.add_state(state);
  builder_.add_commonDataVersion(commonDataVersion);
  return builder_.Finish();
}

}  // namespace dji_osdk_ros

namespace mavros_msgs {

struct Altitude FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AltitudeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MONOTONIC = 6,
    VT_AMSL = 8,
    VT_LOCAL = 10,
    VT_RELATIVE = 12,
    VT_TERRAIN = 14,
    VT_BOTTOM_CLEARANCE = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float monotonic() const {
    return GetField<float>(VT_MONOTONIC, 0.0f);
  }
  float amsl() const {
    return GetField<float>(VT_AMSL, 0.0f);
  }
  float local() const {
    return GetField<float>(VT_LOCAL, 0.0f);
  }
  float relative() const {
    return GetField<float>(VT_RELATIVE, 0.0f);
  }
  float terrain() const {
    return GetField<float>(VT_TERRAIN, 0.0f);
  }
  float bottom_clearance() const {
    return GetField<float>(VT_BOTTOM_CLEARANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_MONOTONIC, 4) &&
           VerifyField<float>(verifier, VT_AMSL, 4) &&
           VerifyField<float>(verifier, VT_LOCAL, 4) &&
           VerifyField<float>(verifier, VT_RELATIVE, 4) &&
           VerifyField<float>(verifier, VT_TERRAIN, 4) &&
           VerifyField<float>(verifier, VT_BOTTOM_CLEARANCE, 4) &&
           verifier.EndTable();
  }
};

struct AltitudeBuilder {
  typedef Altitude Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Altitude::VT___METADATA, __metadata);
  }
  void add_monotonic(float monotonic) {
    fbb_.AddElement<float>(Altitude::VT_MONOTONIC, monotonic, 0.0f);
  }
  void add_amsl(float amsl) {
    fbb_.AddElement<float>(Altitude::VT_AMSL, amsl, 0.0f);
  }
  void add_local(float local) {
    fbb_.AddElement<float>(Altitude::VT_LOCAL, local, 0.0f);
  }
  void add_relative(float relative) {
    fbb_.AddElement<float>(Altitude::VT_RELATIVE, relative, 0.0f);
  }
  void add_terrain(float terrain) {
    fbb_.AddElement<float>(Altitude::VT_TERRAIN, terrain, 0.0f);
  }
  void add_bottom_clearance(float bottom_clearance) {
    fbb_.AddElement<float>(Altitude::VT_BOTTOM_CLEARANCE, bottom_clearance, 0.0f);
  }
  explicit AltitudeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Altitude> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Altitude>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Altitude> CreateAltitude(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float monotonic = 0.0f,
    float amsl = 0.0f,
    float local = 0.0f,
    float relative = 0.0f,
    float terrain = 0.0f,
    float bottom_clearance = 0.0f) {
  AltitudeBuilder builder_(_fbb);
  builder_.add_bottom_clearance(bottom_clearance);
  builder_.add_terrain(terrain);
  builder_.add_relative(relative);
  builder_.add_local(local);
  builder_.add_amsl(amsl);
  builder_.add_monotonic(monotonic);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

}  // namespace mavros_msgs

namespace std_msgs {

}  // namespace std_msgs

namespace geometry_msgs {

}  // namespace geometry_msgs

namespace sensor_msgs {

}  // namespace sensor_msgs

namespace amrl_msgs {

}  // namespace amrl_msgs

namespace nav_msgs {

}  // namespace nav_msgs

namespace std_srvs {

}  // namespace std_srvs

namespace aerialcore_common {

}  // namespace aerialcore_common

namespace dji_osdk_ros {

}  // namespace dji_osdk_ros

namespace mavros_msgs {

}  // namespace mavros_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SCHEMAMAIN_H_
